def main(stri):
    if stri == "minmax":
        text = "#divide_and_conqure_method\ndef divideAndConquer_Max(arr, ind, len):\nmaximum = -1;\n\nif (ind >= len - 2):\nif (arr[ind] > arr[ind + 1]):\nreturnarr[ind];\n\nelse:\nreturn arr[ind + 1];\n\nmaximum = divideAndConquer_Max(arr, ind + 1, len);\n\nif (arr[ind] > maximum):\nreturn arr[ind];\nelse:\nreturn maximum;\n\ndef divideAndConquer_Min(arr, ind, len):\nminimum = 0;\nif (ind >= len - 2):\nif (arr[ind] < arr[ind + 1]):\nreturn arr[ind];\nelse:\nreturn arr[ind + 1];\n\nminimum = divideAndConquer_Min(arr, ind + 1, len);\nif (arr[ind] < minimum):\nreturn arr[ind];\nelse:\nreturn minimum;\n\nif __name__ == '__main__':\n\nminimum, maximum = 0, -1;\narr = [6, 4, 8, 90, 12, 56, 7, 1, 63];\n\nmaximum = divideAndConquer_Max(arr, 0, 9);\nminimum = divideAndConquer_Min(arr, 0, 9);\n\nprint('The minimum number in the array is: ', minimum);\nprint('The maximum number in the array is: ', maximum);\n\n\n\n\n#for_loop_method\nnumbers = [55, 4, 92, 1, 104, 64, 73, 99, 20]\nmax_value = None\nfor num in numbers:\n\tif (max_value is None or num > max_value):\n\t\tmax_value = num\nprint('Maximum value:', max_value)"

    elif stri == "binarysearch":
        text= 'import numpy as np\n\narr = np.random.randint(0,10000,100)\narr = sorted(arr)\nprint("Array is",arr)\nkey = int(input("Enter Key"))\nlow = 0\nhigh = len(arr)-1\n\n\ndef binary_search(arr,low,high,key):\n\n\twhile(low<high):\n\t\tmid = int((low + high) / 2)\n\n\t\tif (arr[mid] == key):\n\t\t\treturn mid\n\n\t\tif(arr[mid] < key):\n\t\t\tlow = mid + 1\n\n\t\telse :\n\t\t\thigh = mid - 1\n\n\treturn "not present in array"\n\nprint("Element is present at index",binary_search(arr,low,high,key))\n\n\n\n\nimport numpy as np\n\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (high + low) // 2\n\t\t\n\t\tif arr[mid] == x:\n\t\t\treturn mid\n\t\t\n\t\telif arr[mid] > x:\n\t\t\treturn binary_search(arr, low, mid - 1, x)\n\t\t\n\t\telse:\n\t\t\treturn binary_search(arr, mid + 1, high, x)\n\t\t\n\telse:\n\t\treturn -1\n\narr = np.random.randint(0,10000,100)\narr = sorted(arr)\nprint("Array is",arr)\nkey = int(input("Enter Key"))\n\nresult = binary_search(arr, 0, len(arr) - 1, key)\n\nif result != -1:\n\tprint("Element is present at index", str(result))\nelse:\n\tprint("Element is not present in array")'

    elif stri == "quicksort":
        text= 'import numpy as np\n\ndef partition(arr, low, high):\n\t    i = low\n\t    j = high - 1\n\t    pivot = arr[high]\n\t\n\t    while i < j:\n\t\t        while i < high and arr[i] < pivot:\n\t\t\t            i = i + 1\n\t\t\n\t\t        while j > low and arr[j] > pivot:\n\t\t\t            j = j - 1\n\t\t\n\t\t        if (i<j):\n\t\t\t            arr[i], arr[j] = arr[j], arr[i]\n\t\t\n\t    if (arr[i]>pivot):\n\t\t        arr[i], arr[high] = arr[high], arr[i]\n\t\n\t    return i\n\ndef quicksort(arr, low, high):\n\t    if (low < high):\n\t\t        partition_position = partition(arr, low, high)\n\t\t        quicksort(arr, partition_position + 1, high)\n\t\t        quicksort(arr, low, partition_position - 1)\n\n\narr = np.random.randint(0,10000,10)\nprint("Unsorted array is",arr)\nquicksort(arr, 0, len(arr) - 1)\nprint("Sorted array is:", arr)\n\n\n\n\n\n\n\nimport numpy as np\n\ndef partition(arr, low, high):\n\t    i = low\n\t    j = high - 1\n\t    pivot = arr[high]\n\t\n\t    while i < j:\n\t\t        while i < high and arr[i] < pivot:\n\t\t\t            i = i + 1\n\t\t\n\t\t        while j > low and arr[j] > pivot:\n\t\t\t            j = j - 1\n\t\t\n\t\t        if (i<j):\n\t\t\t            arr[i], arr[j] = arr[j], arr[i]\n\t\t\n\t    if (arr[i]>pivot):\n\t\t        arr[i], arr[high] = arr[high], arr[i]\n\t\n\t    return i\n\ndef partitionrand(arr, low, high):\n\t\n\t    randpivot = random.randint(low, high)\n\t\n\t    arr[low], arr[randpivot] = arr[randpivot], arr[low]\n\t    return partition(arr, low, high)\n\t\ndef quicksort(arr, low, high):\n\t    if (low < high):\n\t\t        partition_position = partitionrand(arr, low, high)\n\t\t        quicksort(arr, partition_position + 1, high)\n\t\t        quicksort(arr, low, partition_position - 1)\n\n\n\narr = np.random.randint(0,10000,10)\nprint("Unsorted array is",arr)\nquicksort(arr, 0, len(arr) - 1)\nprint("Sorted array is:", arr)'

    elif stri == "mergesort":
        text = 'import numpy as np\n\ndef mergeSort(arr):\n\t    if len(arr) > 1:\n\t\t\n\t\t        mid = len(arr) // 2\n\t\t        L = arr[:mid]\n\t\t        R = arr[mid:]\n\t\t        \n\t\t        mergeSort(L)\n\t\t        mergeSort(R)\n\t\t\n\t\t        i = j = k = 0\n\t\t\n\t\t        while i < len(L) and j < len(R):\n\t\t\t            if L[i] < R[j]:\n\t\t\t\t                arr[k] = L[i]\n\t\t\t\t                i += 1\n\t\t\t            else:\n\t\t\t\t                arr[k] = R[j]\n\t\t\t\t                j += 1\n\t\t\t            k += 1\n\t\t\n\t\t        while i < len(L):\n\t\t\t            arr[k] = L[i]\n\t\t\t            i += 1\n\t\t\t            k += 1\n\t\t\n\t\t        while j < len(R):\n\t\t\t            arr[k] = R[j]\n\t\t\t            j += 1\n\t\t\t            k += 1\n\t            \n\nlist1 = np.random.randint(0,100,10)\nlist = []\n\nfor i in range(len(list1)):\n\t    list.append(list1[i])\n\nprint("Unsorted list",list)\nmergeSort(list)\nprint("Sorted list", list)'

    elif stri == "selectionsort":
        text = 'import numpy as np\n\ndef selectionsort(arr):\n\t\n\t    for i in range(len(arr)-1):\n\t\t        mini = i\n\t\t        for j in range(i+1,len(arr)):\n\t\t\t            if(arr[j]<arr[mini]):\n\t\t\t\t                mini = j\n\t\t\n\t\t        if(mini != i):\n\t\t\t            arr[mini], arr[i] = arr[i], arr[mini]\n\t\t\n\t\n\nlist1 = np.random.randint(0,100,10)\narr = []\n\nfor i in range(len(list1)):\n\t    arr.append(list1[i])\n\nprint("Unsorted list",arr)\nselectionsort(arr)\nprint("Sorted list", arr)'

    elif stri == "insertionsort":
        text = 'import numpy as np\n\ndef insertionsort(arr):\n\t\n\t    for i in range(1,len(arr)):\n\t\t        key = arr[i]\n\t\t        j = i-1\n\t\t\n\t\t        while j>=0 and key < arr[j]:\n\t\t\t            arr[j+1] = arr[j]\n\t\t\t            j = j-1\n\t\t            \n\t\t        arr[j+1] = key\n\t\n\nlist1 = np.random.randint(0,100,10)\narr = []\n\nfor i in range(len(list1)):\n\t    arr.append(list1[i])\n\nprint("Unsorted list",arr)\ninsertionsort(arr)\nprint("Sorted list", arr)'

    elif stri == "knapsack":
        text='val1=[10,5,15,7,6,18,3]\nW =[2,3,5,7,1,4,1]\nn=len(val1)\nmaxval=0\nwt =15\nratio1=[]\nfor i in range(n):\n\t    ratio1.append(val1[i]/W[i])\n\nfor i in range(len(ratio1)):\n\t    k = ratio1.index(max(ratio1))\n\t    \n\t    if wt==0:\n\t\t        break\n\t    elif wt>=W[k]:\n\t\t        maxval= maxval+ratio1[k]*W[k]\n\t\t        wt= wt-W[k]\n\t\t        ratio1[k]=0\n\t    else:\n\t\t        maxval=maxval+ratio1[k]*wt\n\t\t        wt=0\n\t\t        ratio1[k]=0\nprint(maxval)\n\n\n\n\n\nimport random\nimport timeit\ndef knapSack(W, wt, val, n):\n\t    K = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\t\n\t    # Build table K[][] in bottom up manner\n\t    for i in range(n + 1):\n\t\t        for w in range(W + 1):\n\t\t\t            if i == 0 or w == 0:\n\t\t\t\t                K[i][w] = 0\n\t\t\t            elif wt[i-1] <= w:\n\t\t\t\t                K[i][w] = max(val[i-1]\n\t\t\t\t                          + K[i-1][w-wt[i-1]],\n\t\t\t\t                              K[i-1][w])\n\t\t\t            else:\n\t\t\t\t                K[i][w] = K[i-1][w]\n\t\n\t    return K[n][W]\n\n# Driver code\nn = int(input("Enter number of items: "))\nval =random.sample(range(1,n+1),n)\nval = [int(v) for v in val]\nprint(val)\nwt =random.sample(range(1,n+1),n)\nwt = [int(w) for w in wt]\nprint(wt)\nW = int(input("Enter maximum weight: "))\n\nt1=timeit.default_timer()\nprint(knapSack(W, wt, val, n))\nt2=timeit.default_timer()\nprint("The time taken is:",t2-t1)'

    elif stri == "salesman":
        text='from sys import maxsize\nfrom itertools import permutations\nV = 4\n\ndef travellingSalesmanProblem(graph, s):\n\t	vertex = []\n\t	for i in range(V):\n\t\t		if i != s:\n\t\t\t			vertex.append(i)\n\t\n\t	min_path = maxsize\n\t	next_permutation=permutations(vertex)\n\t	for i in next_permutation:\n\t\t		current_pathweight = 0\n\t\t		k = s\n\t\t		for j in i:\n\t\t\t			current_pathweight += graph[k][j]\n\t\t\t			k = j\n\t\t		current_pathweight += graph[k][s]\n\t\t		min_path = min(min_path, current_pathweight)\n\t		\n\t	return min_path\n\n\nif __name__ == "__main__":\n\t	graph = [[0, 10, 15, 20], [10, 0, 35, 25],\n\t			[15, 35, 0, 30], [20, 25, 30, 0]]\n\t	s = 0\n\t	print(travellingSalesmanProblem(graph, s))\n'

    elif stri == "sumofsubset":
        text = 'def subset(set,sum,n):\n\t    if sum==0:\n\t\t        return True\n\t    elif sum!=0 and n==0:\n\t\t        return False\n\t    elif set[n-1]>sum:\n\t\t        return subset(set,sum,n-1)\n\t    else:\n\t\t        return subset(set,sum,n-1) or subset(set,sum-set[n-1],n-1)\n      \n\nset = [3, 34, 4, 12, 5, 2]\nsum = 18\nn = len(set)\nx = subset(set,sum,n)\nprint(x)'

    elif stri == "matrixchain":
        text = "import numpy as np\ndef matrix_product(p):\n\t    length = len(p) \n\t \n\t    \n\t    m = [[-1]*length for _ in range(length)]\n\t    s = [[-1]*length for _ in range(length)]\n\t \n\t    matrix_product_helper(p, 1, length - 1, m, s)\n\t \n\t    return m, s\n \n \ndef matrix_product_helper(p, start, end, m, s):\n\t\n\t    if m[start][end] >= 0:\n\t\t        return m[start][end]\n\t \n\t    if start == end:\n\t\t        q = 0\n\t    else:\n\t\t        q = float('inf')\n\t\t        for k in range(start, end):\n\t\t\t            temp = matrix_product_helper(p, start, k, m, s) \\n\t\t\t                   + matrix_product_helper(p, k + 1, end, m, s) \\n\t\t\t                   + p[start - 1]*p[k]*p[end]\n\t\t\t            if q > temp:\n\t\t\t\t               q = temp\n\t\t\t\t               s[start][end] = k\n\t \n\t    m[start][end] = q\n\t    return q\n \ndef print_parenthesization(s, start, end):\n\t    if start == end:\n\t\t        print('A[{}]'.format(start), end='')\n\t\t        return\n\t \n\t    k = s[start][end]\n\t \n\t    print('(', end='')\n\t    print_parenthesization(s, start, k)\n\t    print_parenthesization(s, k + 1, end)\n\t    print(')', end='')\n \n \nn = int(input('Enter number of matrices: '))\np = []\nfor i in range(n):\n\t    temp = int(input('Enter  P{}: '.format(i)))\n\t    p.append(temp)\ntemp = int(input('Enter P{}: '.format(n)))\np.append(temp)\n \nm, s = matrix_product(p)\nprint('The number of scalar multiplications needed:', m[1][n])\nprint('Optimal parenthesization: ', end='')\nprint_parenthesization(s, 1, n)\nprint('\n')\n\nfor i in range(1,7):\n\t    for j in range(1,7):\n\t\t        if(i<=j):\n\t\t\t            print(m[j][i],end=" ")\n\t    print('\n')\n    "

    elif stri == "lcs":
        text = 'X = "QueSeraSera"\nY = "Coursera"\nm=len(X)\nn=len(Y)\nval=[]\nk = [[0 for x in range(n+1)] for x in range(m+1)]\nfor i in range(m+1):\n\t    for j in range(n+1):\n\t\t        if i==0 or j==0:\n\t\t\t            k[i][j]=0\n\t\t        elif X[i-1]==Y[j-1]:\n\t\t\t            k[i][j]=k[i-1][j-1]+1\n\t\t\n\t\t\n\t        else:\n\t\t            k[i][j]=max(k[i-1][j],k[i][j-1])\n\n\nprint(k[m][n])\nindex = k[m][n]\n\nlcs_algo = [""] * (index+1)\nlcs_algo[index] = ""\nwhile i > 0 and j > 0:\n\t\n\t    if X[i-1] == Y[j-1]:\n\t\t        lcs_algo[index-1] = X[i-1]\n\t\t        i -= 1\n\t\t        j -= 1\n\t\t        index -= 1\n\t\n\t    elif k[i-1][j] > k[i][j-1]:\n\t\t        i -= 1\n\t    else:\n\t\t        j -= 1\n\nprint("X : " + X + "\nY : " + Y)\nprint("LCS: " + "".join(lcs_algo))'

    elif stri == "nqueen":
        text = 'N = 4\n\ndef printSolution(board):\n\t	for i in range(N):\n\t\t		for j in range(N):\n\t\t\t			print (board[i][j],end=' ')\n\t\t		print()\n\n\n\ndef isSafe(board, row, col):\n\t\n\t	for i in range(col):\n\t\t		if board[row][i] == 1:\n\t\t\t			return False\n\t\n\t	for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n\t\t		if board[i][j] == 1:\n\t\t\t			return False\n\t\n\t	for i, j in zip(range(row, N, 1), range(col, -1, -1)):\n\t\t		if board[i][j] == 1:\n\t\t\t			return False\n\t\n\t	return True\n\ndef solveNQUtil(board, col):\n\t\n\t	if col >= N:\n\t\t		return True\n\t\n\t	for i in range(N):\n\t\t\n\t\t		if isSafe(board, i, col):\n\t\t\t			board[i][col] = 1\n\t\t\n\t\t			if solveNQUtil(board, col + 1) == True:\n\t\t\t				return True\n\t\t\n\t\t			board[i][col] = 0\n\t\n\t	return False\n\ndef solveNQ():\n\t	board = [ [0, 0, 0, 0],\n\t			[0, 0, 0, 0],\n\t			[0, 0, 0, 0],\n\t			[0, 0, 0, 0]\n\t			]\n\t\n\t	if solveNQUtil(board, 0) == False:\n\t\t		print ("Solution does not exist")\n\t\t		return False\n\t\n\t	printSolution(board)\n\t	return True\n\nsolveNQ()\n'

    elif stri == "kruskal":
        text = 'def find(i):\n\t	while parent[i] != i:\n\t\t		i = parent[i]\n\t	return i\n\n\ndef union(i, j):\n\t	a = find(i)\n\t	b = find(j)\n\t	parent[a] = b\n\ndef kruskalMST(cost):\n\t	mincost = 0 \n\t\n\t	for i in range(V):\n\t\t		parent[i] = i\n\t		\n\t	edge_count = 0\n\t	while edge_count < V - 1:\n\t\t		min = INF\n\t\t		a = -1\n\t\t		b = -1\n\t\t		for i in range(V):\n\t\t\t			for j in range(V):\n\t\t\t				if find(i) != find(j) and cost[i][j] < min:\n\t\t\t\t					min = cost[i][j]\n\t\t\t\t					a = i\n\t\t\t\t					b = j\n\t\t		union(a, b)\n\t\t		print("Edge {}:({}, {}) cost:{}".format(edge_count, a, b, min))\n\t\t		edge_count += 1\n\t\t		mincost += min\n\t\n\t	print("Minimum cost= {}".format(mincost))\n\t\n\nV = 5\nparent = [i for i in range(V)]\nINF = float("inf")\ncost = [[INF, 2, INF, 6, INF],\n\t		[2, INF, 3, 8, 5],\n\t		[INF, 3, INF, INF, 7],\n\t		[6, 8, INF, INF, 9],\n\t		[INF, 5, 7, 9, INF]]\n\nkruskalMST(cost)'

    elif stri == 'allpair':
        text = 'INF = 9999\ndef printSolution(n, distance):\n\t    for i in range(n):\n\t\t        for j in range(n):\n\t\t\t            if(distance[i][j] == INF):\n\t\t\t\t                print("INF", end=" ")\n\t            else:\n\t\t\t                print(distance[i][j], end="  ")\n\t        print(" ")\n\ndef all_pair(n, G):\n\t    distance = G\n\t    for k in range(n):\n\t\t        for i in range(n):\n\t\t\t            for j in range(n):\n\t\t\t\t                distance[i][j] = min(distance[i][j], distance[i][k]+distance[k][j])\n\n\nG = [[0,4,11],\n     [6,0,2],\n     [3,INF,0],\n    ]\n\nn = 3\n# n = int(input("Enter number of vertices: "))\n#\n# G = []\n# print("Enter the entries rowwise:")\n#\n# for i in range(n):\n\t#     a =[]\n\t#     for j in range(n):\n\t\t#          a.append(int(input()))\n\t#     G.append(a)\n\nfor i in range(n):\n\t    for j in range(n):\n\t\t        print(G[i][j], end = "  ")\n\t    print()\nprint("-----------------------------------")\nall_pair(n, G)\nprintSolution(n,G)'

    elif stri == "dijkstra":
        text = 'class Graph():\n\n	def __init__(self, vertices):\n\t		self.V = vertices\n\t		self.graph = [[0 for column in range(vertices)]\n\t					for row in range(vertices)]\n\n	def printSolution(self, dist):\n\t		print("Vertex \t Distance from Source")\n\t		for node in range(self.V):\n\t\t			print(node, "\t\t", dist[node])\n\n	def minDistance(self, dist, sptSet):\n\t\n\t		min = 1e7\n\t		\n\t		for v in range(self.V):\n\t\t			if dist[v] < min and sptSet[v] == False:\n\t\t\t				min = dist[v]\n\t\t\t				min_index = v\n\t\n\t		return min_index\n\n\n	def dijkstra(self, src):\n\n\t		dist = [1e7] * self.V\n\t		dist[src] = 0\n\t		sptSet = [False] * self.V\n\t\n\t		for cout in range(self.V):\n\t\t\n\t\t			u = self.minDistance(dist, sptSet)\n\t\t\n\t\t			sptSet[u] = True\n\t\t\n\t\t			for v in range(self.V):\n\t\t\t				if (self.graph[u][v] > 0 and\n\t\t\t				sptSet[v] == False and\n\t\t\t				dist[v] > dist[u] + self.graph[u][v]):\n\t\t\t					dist[v] = dist[u] + self.graph[u][v]\n\t\n\t		self.printSolution(dist)\n\n\ng = Graph(9)\ng.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],\n		[4, 0, 8, 0, 0, 0, 0, 11, 0],\n		[0, 8, 0, 7, 0, 4, 0, 0, 2],\n		[0, 0, 7, 0, 9, 14, 0, 0, 0],\n		[0, 0, 0, 9, 0, 10, 0, 0, 0],\n		[0, 0, 4, 14, 10, 0, 2, 0, 0],\n		[0, 0, 0, 0, 0, 2, 0, 1, 6],\n		[8, 11, 0, 0, 0, 0, 1, 0, 7],\n		[0, 0, 2, 0, 0, 0, 6, 7, 0]\n		]\n\ng.dijkstra(3)\n'

    elif stri == "grapgcoloring" :
        text = 'def graphColour(graph, m, colors, n):\n\t    if m+1 == n :\n\t\t        return True\n\t\n\t    for c in range(1, m+1):\n\t\t        if isSafe(n, graph, colors, c):\n\t\t\t            colors[n] = c\n\t\t\t            if graphColour(graph, m, colors, n+1):\n\t\t\t\t                return True\n\t\t\t           colors[n] = 0\n\ndef isSafe(n, graph, colors, c):\n\t    for i in range(n):\n\t\t        if graph[n][i] and c == colors[i]:\n\t\t\t            return False\n\t    return True\n\nn = int(input("Enter the value of number of nodes (n): "))\nG = [[0 for coloumn in range (n)] for row in range (n)]\nfor i in range(n):\n    for j in range(n):\n\t        print("Enter adjacency matrix [", (i), "][", (j), "]: ")\n\t        G[i][j] = int(input())\n\nm = int(input("Enter the value of number of colors (m): "))  \n\ncolors = [0 for i in range(n)]\n\nif graphColour(G, m, colors, 0):\n\t    print("Solution is: ", colors) \nelse:\n\t    print("No solution")'

    else:
        text = "menu:\n1)minmax\n2)binarysearch\n3)quicksort\n" \
               "4)mergesort\n5)selectionsort\n6)insertionsort\n" \
               "7)knapsack\n8)salesman\n9)sumofsubset\n" \
               "10)matrixchain\n11)lcs\n12)nqueen\n13)kruskal\n14)allpair" \
               "\n15)dijkstra\n16)graphcoloring  "
    return text

if __name__ =="__main__":
    print(main("mergesort"))








